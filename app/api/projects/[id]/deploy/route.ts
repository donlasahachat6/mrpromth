/**
 * API Route: Deploy Project to GitHub and Vercel
 * POST /api/projects/[id]/deploy
 */

import { NextRequest, NextResponse } from 'next/server'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { createGitHubClient } from '@/lib/integrations/github-client'
import { createVercelClient } from '@/lib/integrations/vercel-client'
import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'

export const dynamic = 'force-dynamic';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const projectId = params.id
    const body = await request.json()
    
    const {
      githubToken,
      vercelToken,
      repoName,
      repoPrivate = false,
      deployToVercel = true
    } = body
    
    // Validate inputs
    if (!githubToken) {
      return NextResponse.json(
        { error: 'GitHub token is required' },
        { status: 400 }
      )
    }
    
    if (deployToVercel && !vercelToken) {
      return NextResponse.json(
        { error: 'Vercel token is required for deployment' },
        { status: 400 }
      )
    }
    
    // Get user from session
    const supabase = createRouteHandlerClient({ cookies })
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }
    
    // Get workflow/project details
    const { data: workflow, error: workflowError } = await supabase
      .from('workflows')
      .select('*')
      .eq('id', projectId)
      .eq('user_id', user.id)
      .single()
    
    if (workflowError || !workflow) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      )
    }
    
    // Get project files
    const { data: files, error: filesError } = await supabase
      .from('project_files')
      .select('*')
      .eq('workflow_id', projectId)
    
    if (filesError || !files || files.length === 0) {
      return NextResponse.json(
        { error: 'No files found for this project' },
        { status: 404 }
      )
    }
    
    // Step 1: Create GitHub repository
    const githubClient = createGitHubClient(githubToken)
    
    // Get GitHub username
    const githubUser = await githubClient.getAuthenticatedUser()
    const githubUsername = githubUser.login
    
    // Create repository
    const finalRepoName = repoName || workflow.project_name || `project-${projectId.substring(0, 8)}`
    
    const createRepoResult = await githubClient.createRepository({
      name: finalRepoName,
      description: `Generated by Mr.Prompt - ${workflow.prompt?.substring(0, 100)}`,
      private: repoPrivate,
      autoInit: true
    })
    
    if (!createRepoResult.success) {
      return NextResponse.json(
        { 
          error: 'Failed to create GitHub repository',
          details: createRepoResult.error
        },
        { status: 500 }
      )
    }
    
    // Wait a bit for GitHub to initialize the repo
    await new Promise(resolve => setTimeout(resolve, 2000))
    
    // Step 2: Push files to GitHub
    const filesToPush = files.map(file => ({
      path: file.file_path,
      content: file.content || ''
    }))
    
    const pushResult = await githubClient.pushFiles({
      owner: githubUsername,
      repo: finalRepoName,
      files: filesToPush,
      message: 'Initial commit from Mr.Prompt'
    })
    
    if (!pushResult.success) {
      return NextResponse.json(
        { 
          error: 'Failed to push files to GitHub',
          details: pushResult
        },
        { status: 500 }
      )
    }
    
    // Update workflow with GitHub URL
    await supabase
      .from('workflows')
      .update({
        github_url: createRepoResult.url,
        updated_at: new Date().toISOString()
      })
      .eq('id', projectId)
    
    const result: any = {
      success: true,
      github: {
        url: createRepoResult.url,
        cloneUrl: createRepoResult.cloneUrl,
        commitUrl: pushResult.commitUrl
      }
    }
    
    // Step 3: Deploy to Vercel (optional)
    if (deployToVercel) {
      try {
        const vercelClient = createVercelClient(vercelToken)
        
        // Create Vercel project linked to GitHub
        const vercelProject = await vercelClient.createProject({
          name: finalRepoName,
          framework: 'nextjs',
          gitRepository: {
            type: 'github',
            repo: `${githubUsername}/${finalRepoName}`
          },
          environmentVariables: [
            {
              key: 'NEXT_PUBLIC_APP_URL',
              value: `https://${finalRepoName}.vercel.app`,
              target: ['production', 'preview']
            }
          ]
        })
        
        if (vercelProject.success) {
          // Link GitHub repo to Vercel project
          await vercelClient.linkGitHubRepo(
            vercelProject.project.id,
            githubUsername,
            finalRepoName
          )
          
          // Update workflow with Vercel URL
          await supabase
            .from('workflows')
            .update({
              vercel_url: vercelProject.url,
              deployment_url: `https://${finalRepoName}.vercel.app`,
              updated_at: new Date().toISOString()
            })
            .eq('id', projectId)
          
          result.vercel = {
            url: vercelProject.url,
            deploymentUrl: `https://${finalRepoName}.vercel.app`,
            projectId: vercelProject.project.id
          }
        }
      } catch (vercelError) {
        console.error('[Deploy API] Vercel deployment error:', vercelError)
        result.vercel = {
          error: vercelError instanceof Error ? vercelError.message : String(vercelError)
        }
      }
    }
    
    return NextResponse.json(result)
    
  } catch (error) {
    console.error('[Deploy API] Error:', error)
    return NextResponse.json(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    )
  }
}
