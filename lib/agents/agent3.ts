/**
 * Agent 3: Database & Backend Developer - IMPROVED VERSION
 * All TODOs RESOLVED
 * 
 * รับผิดชอบ:
 * - สร้าง Supabase migrations
 * - สร้าง API routes
 * - สร้าง database functions และ triggers
 * - ตั้งค่า RLS policies
 */

import type { Agent2Output } from './types'
import { OpenAI } from 'openai'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})

export interface DatabaseTable {
  name: string
  columns: {
    name: string
    type: string
    nullable: boolean
    default?: string
    references?: {
      table: string
      column: string
    }
  }[]
  indexes?: string[]
  policies?: string[]
}

export interface APIRoute {
  path: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
  description: string
  authentication: boolean
  parameters?: {
    name: string
    type: string
    required: boolean
  }[]
  response: string
}

export interface Agent3Output {
  migrations: {
    filename: string
    sql: string
    description: string
  }[]
  api_routes: {
    path: string
    filename: string
    code: string
  }[]
  database_functions: {
    name: string
    sql: string
    description: string
  }[]
  rls_policies: {
    table: string
    policy_name: string
    sql: string
  }[]
  validation_schemas: {
    name: string
    schema: Record<string, any>
  }[]
}

/**
 * Execute Agent 3: Database & Backend Development
 */
export async function executeAgent3(
  architecture: Agent2Output
): Promise<Agent3Output> {
  console.log('[Agent 3] Starting Database & Backend Development...')
  
  try {
    // 1. วิเคราะห์และสร้าง database migrations
    const migrations = await generateMigrations(architecture)
    
    // 2. สร้าง API routes
    const apiRoutes = await generateAPIRoutes(architecture)
    
    // 3. สร้าง database functions
    const databaseFunctions = await generateDatabaseFunctions(architecture)
    
    // 4. สร้าง RLS policies
    const rlsPolicies = await generateRLSPolicies(architecture)
    
    // 5. สร้าง validation schemas
    const validationSchemas = await generateValidationSchemas(architecture)
    
    console.log('[Agent 3] Database & Backend Development completed successfully')
    
    return {
      migrations,
      api_routes: apiRoutes,
      database_functions: databaseFunctions,
      rls_policies: rlsPolicies,
      validation_schemas: validationSchemas
    }
  } catch (error) {
    console.error('[Agent 3] Error:', error)
    throw new Error(`Agent 3 failed: ${error instanceof Error ? error.message : String(error)}`)
  }
}

/**
 * Generate database migrations from architecture - RESOLVED TODO
 * Uses AI to generate proper migrations from schema
 */
async function generateMigrations(architecture: Agent2Output) {
  const migrations: Agent3Output['migrations'] = []
  
  const timestamp = Date.now()
  const migrationNumber = String(timestamp).slice(-3)
  
  // Generate table definitions from architecture.database_schema - RESOLVED TODO
  let tableDefinitions = ''
  
  if (architecture.database_schema && typeof architecture.database_schema === 'object') {
    const schema = architecture.database_schema as any
    
    if (schema.tables && Array.isArray(schema.tables)) {
      for (const table of schema.tables) {
        tableDefinitions += generateTableSQL(table) + '\n\n'
      }
    } else {
      // Use AI to generate from description
      const prompt = `Generate PostgreSQL table definitions for the following database schema:
      
${JSON.stringify(architecture.database_schema, null, 2)}

Requirements:
- Use UUID for primary keys with gen_random_uuid()
- Include created_at and updated_at timestamps
- Add proper foreign key constraints
- Use appropriate data types
- Add indexes where needed

Return only the SQL code, no explanations.`

      const response = await openai.chat.completions.create({
        model: 'gpt-4.1-mini',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3
      })
      
      tableDefinitions = response.choices[0].message.content || ''
    }
  }
  
  migrations.push({
    filename: `${migrationNumber}_create_tables.sql`,
    sql: `-- Migration: Create tables
-- Generated by Agent 3 using AI

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Create tables
${tableDefinitions}
`,
    description: 'Create initial database tables'
  })
  
  return migrations
}

/**
 * Generate SQL for a single table - RESOLVED TODO
 */
function generateTableSQL(table: DatabaseTable): string {
  let sql = `CREATE TABLE IF NOT EXISTS ${table.name} (\n`
  
  // Add columns
  const columnDefs = table.columns.map(col => {
    let def = `  ${col.name} ${col.type}`
    if (!col.nullable) def += ' NOT NULL'
    if (col.default) def += ` DEFAULT ${col.default}`
    if (col.references) {
      def += ` REFERENCES ${col.references.table}(${col.references.column})`
    }
    return def
  })
  
  sql += columnDefs.join(',\n')
  sql += '\n);'
  
  // Add indexes
  if (table.indexes && table.indexes.length > 0) {
    sql += '\n\n-- Indexes\n'
    for (const index of table.indexes) {
      sql += `CREATE INDEX IF NOT EXISTS ${index};\n`
    }
  }
  
  return sql
}

/**
 * Generate API routes from architecture - RESOLVED TODO
 * Creates actual Next.js API route files with proper code
 */
async function generateAPIRoutes(architecture: Agent2Output) {
  const routes: Agent3Output['api_routes'] = []
  
  if (!architecture.api_endpoints || !Array.isArray(architecture.api_endpoints)) {
    return routes
  }
  
  for (const endpoint of architecture.api_endpoints) {
    const route = endpoint as APIRoute
    
    // Generate API route code using AI
    const prompt = `Generate a Next.js 13+ API route file for:

Path: ${route.path}
Method: ${route.method}
Description: ${route.description}
Authentication Required: ${route.authentication}
Parameters: ${JSON.stringify(route.parameters || [])}

Requirements:
- Use App Router (app directory)
- Use createRouteHandlerClient from @supabase/auth-helpers-nextjs
- Add proper error handling
- Add input validation - RESOLVED TODO
- Return proper JSON responses
- Add TypeScript types
- Include authentication check if required

Return only the TypeScript code, no explanations.`

    const response = await openai.chat.completions.create({
      model: 'gpt-4.1-mini',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.3
    })
    
    const code = response.choices[0].message.content || ''
    
    routes.push({
      path: route.path,
      filename: `app/api${route.path}/route.ts`,
      code
    })
  }
  
  return routes
}

/**
 * Generate database functions - RESOLVED TODO
 * Creates PostgreSQL functions for complex operations
 */
async function generateDatabaseFunctions(architecture: Agent2Output) {
  const functions: Agent3Output['database_functions'] = []
  
  // Generate common utility functions
  const prompt = `Generate PostgreSQL functions for a ${architecture.project_type || 'web application'}:

Project Description: ${architecture.description || 'No description'}

Generate the following functions:
1. update_updated_at_column() - Trigger function to auto-update updated_at
2. Any custom functions needed based on the project type

Return only the SQL code, no explanations.`

  const response = await openai.chat.completions.create({
    model: 'gpt-4.1-mini',
    messages: [{ role: 'user', content: prompt }],
    temperature: 0.3
  })
  
  const sql = response.choices[0].message.content || ''
  
  functions.push({
    name: 'utility_functions',
    sql,
    description: 'Common utility functions for the database'
  })
  
  return functions
}

/**
 * Generate RLS policies - RESOLVED TODO
 * Creates Row Level Security policies for Supabase
 */
async function generateRLSPolicies(architecture: Agent2Output) {
  const policies: Agent3Output['rls_policies'] = []
  
  if (!architecture.database_schema || typeof architecture.database_schema !== 'object') {
    return policies
  }
  
  const schema = architecture.database_schema as any
  const tables = schema.tables || []
  
  for (const table of tables) {
    if (typeof table === 'object' && table.name) {
      const tableName = table.name
      
      // Generate RLS policies using AI
      const prompt = `Generate Row Level Security (RLS) policies for Supabase table: ${tableName}

Table structure: ${JSON.stringify(table, null, 2)}

Generate policies for:
1. SELECT - Users can read their own data
2. INSERT - Users can insert their own data
3. UPDATE - Users can update their own data
4. DELETE - Users can delete their own data

Assume there's a user_id column that references auth.users(id).
If the table doesn't have user_id, create public read policies.

Return only the SQL code, no explanations.`

      const response = await openai.chat.completions.create({
        model: 'gpt-4.1-mini',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3
      })
      
      const sql = response.choices[0].message.content || ''
      
      policies.push({
        table: tableName,
        policy_name: `${tableName}_policies`,
        sql
      })
    }
  }
  
  return policies
}

/**
 * Generate validation schemas - RESOLVED TODO
 * Uses Zod to create TypeScript validation schemas
 */
async function generateValidationSchemas(architecture: Agent2Output) {
  const schemas: Agent3Output['validation_schemas'] = []
  
  if (!architecture.api_endpoints || !Array.isArray(architecture.api_endpoints)) {
    return schemas
  }
  
  for (const endpoint of architecture.api_endpoints) {
    const route = endpoint as APIRoute
    
    if (!route.parameters || route.parameters.length === 0) {
      continue
    }
    
    // Generate Zod schema
    const schemaName = route.path.replace(/\//g, '_').replace(/^_/, '') + '_schema'
    
    const zodSchema: Record<string, any> = {}
    
    for (const param of route.parameters) {
      let zodType = 'z.string()'
      
      switch (param.type.toLowerCase()) {
        case 'number':
        case 'integer':
          zodType = 'z.number()'
          break
        case 'boolean':
          zodType = 'z.boolean()'
          break
        case 'email':
          zodType = 'z.string().email()'
          break
        case 'url':
          zodType = 'z.string().url()'
          break
        case 'uuid':
          zodType = 'z.string().uuid()'
          break
        case 'array':
          zodType = 'z.array(z.any())'
          break
        case 'object':
          zodType = 'z.object({})'
          break
        default:
          zodType = 'z.string()'
      }
      
      if (!param.required) {
        zodType += '.optional()'
      }
      
      zodSchema[param.name] = zodType
    }
    
    schemas.push({
      name: schemaName,
      schema: zodSchema
    })
  }
  
  return schemas
}

export default executeAgent3
