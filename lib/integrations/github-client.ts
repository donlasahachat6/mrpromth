/**
 * GitHub Integration Client
 * Auto-create repositories and push generated code
 */

import { Octokit } from '@octokit/rest'
import { readdir, readFile, stat } from 'fs/promises'
import { join } from 'path'

export interface GitHubConfig {
  token: string
  username?: string
}

export interface CreateRepoOptions {
  name: string
  description?: string
  private?: boolean
  autoInit?: boolean
}

export interface PushFilesOptions {
  owner: string
  repo: string
  files: Array<{
    path: string
    content: string
  }>
  branch?: string
  message?: string
}

export class GitHubClient {
  private octokit: Octokit
  private username?: string
  
  constructor(config: GitHubConfig) {
    this.octokit = new Octokit({
      auth: config.token
    })
    this.username = config.username
  }
  
  /**
   * Get authenticated user
   */
  async getAuthenticatedUser() {
    try {
      const { data } = await this.octokit.users.getAuthenticated()
      this.username = data.login
      return data
    } catch (error) {
      throw new Error(`Failed to get authenticated user: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * Create new repository
   */
  async createRepository(options: CreateRepoOptions) {
    try {
      const { data } = await this.octokit.repos.createForAuthenticatedUser({
        name: options.name,
        description: options.description || `Generated by Mr.Prompt`,
        private: options.private ?? false,
        auto_init: options.autoInit ?? true
      })
      
      return {
        success: true,
        repo: data,
        url: data.html_url,
        cloneUrl: data.clone_url
      }
    } catch (error: any) {
      // Check if repo already exists
      if (error.status === 422) {
        return {
          success: false,
          error: 'Repository already exists',
          code: 'REPO_EXISTS'
        }
      }
      
      throw new Error(`Failed to create repository: ${error.message}`)
    }
  }
  
  /**
   * Push files to repository
   */
  async pushFiles(options: PushFilesOptions) {
    const { owner, repo, files, branch = 'main', message = 'Initial commit from Mr.Prompt' } = options
    
    try {
      // Get current commit SHA
      const { data: refData } = await this.octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${branch}`
      })
      
      const currentCommitSha = refData.object.sha
      
      // Get current commit
      const { data: commitData } = await this.octokit.git.getCommit({
        owner,
        repo,
        commit_sha: currentCommitSha
      })
      
      const currentTreeSha = commitData.tree.sha
      
      // Create blobs for all files
      const blobs = await Promise.all(
        files.map(async (file) => {
          const { data: blobData } = await this.octokit.git.createBlob({
            owner,
            repo,
            content: Buffer.from(file.content).toString('base64'),
            encoding: 'base64'
          })
          
          return {
            path: file.path,
            mode: '100644' as const,
            type: 'blob' as const,
            sha: blobData.sha
          }
        })
      )
      
      // Create new tree
      const { data: treeData } = await this.octokit.git.createTree({
        owner,
        repo,
        base_tree: currentTreeSha,
        tree: blobs
      })
      
      // Create new commit
      const { data: newCommitData } = await this.octokit.git.createCommit({
        owner,
        repo,
        message,
        tree: treeData.sha,
        parents: [currentCommitSha]
      })
      
      // Update reference
      await this.octokit.git.updateRef({
        owner,
        repo,
        ref: `heads/${branch}`,
        sha: newCommitData.sha
      })
      
      return {
        success: true,
        commitSha: newCommitData.sha,
        commitUrl: newCommitData.html_url
      }
    } catch (error) {
      throw new Error(`Failed to push files: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * Push directory to repository
   */
  async pushDirectory(
    owner: string,
    repo: string,
    dirPath: string,
    options?: {
      branch?: string
      message?: string
      excludePatterns?: string[]
    }
  ) {
    try {
      // Read all files from directory
      const files = await this.readDirectoryRecursive(
        dirPath,
        '',
        options?.excludePatterns || []
      )
      
      // Push files
      return await this.pushFiles({
        owner,
        repo,
        files,
        branch: options?.branch,
        message: options?.message
      })
    } catch (error) {
      throw new Error(`Failed to push directory: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
  
  /**
   * Read directory recursively
   */
  private async readDirectoryRecursive(
    dirPath: string,
    basePath: string,
    excludePatterns: string[]
  ): Promise<Array<{ path: string; content: string }>> {
    const files: Array<{ path: string; content: string }> = []
    const entries = await readdir(dirPath, { withFileTypes: true })
    
    for (const entry of entries) {
      const fullPath = join(dirPath, entry.name)
      const relativePath = basePath ? join(basePath, entry.name) : entry.name
      
      // Check if should exclude
      if (this.shouldExclude(relativePath, excludePatterns)) {
        continue
      }
      
      if (entry.isDirectory()) {
        // Recursively read subdirectory
        const subFiles = await this.readDirectoryRecursive(
          fullPath,
          relativePath,
          excludePatterns
        )
        files.push(...subFiles)
      } else if (entry.isFile()) {
        // Read file content
        const content = await readFile(fullPath, 'utf-8')
        files.push({
          path: relativePath,
          content
        })
      }
    }
    
    return files
  }
  
  /**
   * Check if path should be excluded
   */
  private shouldExclude(path: string, patterns: string[]): boolean {
    const defaultExcludes = [
      'node_modules',
      '.next',
      '.git',
      'dist',
      'build',
      '.env',
      '.env.local',
      '.DS_Store'
    ]
    
    const allPatterns = [...defaultExcludes, ...patterns]
    
    for (const pattern of allPatterns) {
      if (pattern.includes('*')) {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'))
        if (regex.test(path)) {
          return true
        }
      } else {
        if (path === pattern || path.includes(pattern)) {
          return true
        }
      }
    }
    
    return false
  }
  
  /**
   * Get repository details
   */
  async getRepository(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.get({
        owner,
        repo
      })
      
      return {
        success: true,
        repo: data
      }
    } catch (error: any) {
      if (error.status === 404) {
        return {
          success: false,
          error: 'Repository not found'
        }
      }
      
      throw new Error(`Failed to get repository: ${error.message}`)
    }
  }
  
  /**
   * Delete repository
   */
  async deleteRepository(owner: string, repo: string) {
    try {
      await this.octokit.repos.delete({
        owner,
        repo
      })
      
      return {
        success: true
      }
    } catch (error) {
      throw new Error(`Failed to delete repository: ${error instanceof Error ? error.message : String(error)}`)
    }
  }
}

/**
 * Create GitHub client from environment
 */
export function createGitHubClient(token?: string): GitHubClient {
  const githubToken = token || process.env.GITHUB_TOKEN
  
  if (!githubToken) {
    throw new Error('GitHub token is required. Set GITHUB_TOKEN environment variable.')
  }
  
  return new GitHubClient({
    token: githubToken
  })
}
