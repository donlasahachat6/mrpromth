/**
 * ZIP Generator Utility
 * Creates ZIP archives from project files
 */

import archiver from 'archiver'
import { createWriteStream, createReadStream } from 'fs'
import { readdir, stat, mkdir } from 'fs/promises'
import { join, relative } from 'path'
import { createClient } from '@supabase/supabase-js'

export interface ZipOptions {
  projectPath: string
  outputPath: string
  projectName: string
  excludePatterns?: string[]
}

export interface ZipResult {
  success: boolean
  zipPath: string
  size: number
  fileCount: number
  error?: string
}

/**
 * Create ZIP archive from project directory
 */
export async function createProjectZip(options: ZipOptions): Promise<ZipResult> {
  const { projectPath, outputPath, projectName, excludePatterns = [] } = options
  
  return new Promise(async (resolve, reject) => {
    try {
      // Ensure output directory exists
      const outputDir = outputPath.substring(0, outputPath.lastIndexOf('/'))
      await mkdir(outputDir, { recursive: true })
      
      // Create write stream
      const output = createWriteStream(outputPath)
      const archive = archiver('zip', {
        zlib: { level: 9 } // Maximum compression
      })
      
      let fileCount = 0
      let totalSize = 0
      
      // Handle stream events
      output.on('close', () => {
        resolve({
          success: true,
          zipPath: outputPath,
          size: archive.pointer(),
          fileCount
        })
      })
      
      archive.on('error', (err) => {
        reject({
          success: false,
          zipPath: outputPath,
          size: 0,
          fileCount: 0,
          error: err.message
        })
      })
      
      archive.on('entry', (entry) => {
        if (entry.stats?.isFile()) {
          fileCount++
          totalSize += entry.stats.size
        }
      })
      
      // Pipe archive to output
      archive.pipe(output)
      
      // Add files to archive
      const defaultExcludes = [
        'node_modules',
        '.next',
        '.git',
        'dist',
        'build',
        '.env',
        '.env.local',
        '*.log',
        '.DS_Store'
      ]
      
      const allExcludes = [...defaultExcludes, ...excludePatterns]
      
      // Add directory recursively
      await addDirectoryToArchive(archive, projectPath, '', allExcludes)
      
      // Add README if not exists
      const readmeContent = generateReadme(projectName)
      archive.append(readmeContent, { name: 'README.md' })
      
      // Finalize archive
      await archive.finalize()
      
    } catch (error) {
      reject({
        success: false,
        zipPath: outputPath,
        size: 0,
        fileCount: 0,
        error: error instanceof Error ? error.message : String(error)
      })
    }
  })
}

/**
 * Add directory to archive recursively
 */
async function addDirectoryToArchive(
  archive: archiver.Archiver,
  dirPath: string,
  basePath: string,
  excludePatterns: string[]
): Promise<void> {
  const entries = await readdir(dirPath, { withFileTypes: true })
  
  for (const entry of entries) {
    const fullPath = join(dirPath, entry.name)
    const relativePath = basePath ? join(basePath, entry.name) : entry.name
    
    // Check if should exclude
    if (shouldExclude(relativePath, excludePatterns)) {
      continue
    }
    
    if (entry.isDirectory()) {
      // Recursively add subdirectory
      await addDirectoryToArchive(archive, fullPath, relativePath, excludePatterns)
    } else if (entry.isFile()) {
      // Add file
      const stats = await stat(fullPath)
      archive.file(fullPath, {
        name: relativePath,
        stats
      })
    }
  }
}

/**
 * Check if path should be excluded
 */
function shouldExclude(path: string, patterns: string[]): boolean {
  for (const pattern of patterns) {
    if (pattern.includes('*')) {
      // Wildcard pattern
      const regex = new RegExp(pattern.replace(/\*/g, '.*'))
      if (regex.test(path)) {
        return true
      }
    } else {
      // Exact match or contains
      if (path === pattern || path.includes(pattern)) {
        return true
      }
    }
  }
  return false
}

/**
 * Generate README for project
 */
function generateReadme(projectName: string): string {
  return `# ${projectName}

This project was generated by **Mr.Prompt** - AI-Powered Full-Stack Project Generator.

## üöÄ Getting Started

### Prerequisites
- Node.js 18+ 
- pnpm (recommended) or npm

### Installation

\`\`\`bash
# Install dependencies
pnpm install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your configuration
\`\`\`

### Development

\`\`\`bash
# Run development server
pnpm dev

# Open http://localhost:3000
\`\`\`

### Build

\`\`\`bash
# Build for production
pnpm build

# Start production server
pnpm start
\`\`\`

### Database

\`\`\`bash
# Run migrations (if using Supabase)
# Go to Supabase Dashboard > SQL Editor
# Run the migration files in supabase/migrations/
\`\`\`

## üìÅ Project Structure

\`\`\`
.
‚îú‚îÄ‚îÄ app/              # Next.js app directory
‚îÇ   ‚îú‚îÄ‚îÄ api/          # API routes
‚îÇ   ‚îî‚îÄ‚îÄ ...           # Pages
‚îú‚îÄ‚îÄ components/       # React components
‚îú‚îÄ‚îÄ lib/              # Utility functions
‚îú‚îÄ‚îÄ public/           # Static assets
‚îî‚îÄ‚îÄ supabase/         # Database migrations
\`\`\`

## üõ†Ô∏è Tech Stack

- **Framework**: Next.js 14
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **Database**: Supabase (PostgreSQL)
- **Authentication**: Supabase Auth
- **Deployment**: Vercel

## üìù Notes

- This is a generated project. Review and customize as needed.
- Make sure to set up environment variables before running.
- Check the database migrations before applying them.

## üîó Links

- [Mr.Prompt](https://mrpromth.com) - Generate your next project
- [Next.js Documentation](https://nextjs.org/docs)
- [Supabase Documentation](https://supabase.com/docs)

---

Generated with ‚ù§Ô∏è by **Mr.Prompt**
`
}

/**
 * Upload ZIP to Supabase Storage
 */
export async function uploadZipToStorage(
  zipPath: string,
  projectId: string,
  userId: string
): Promise<{ success: boolean; url?: string; error?: string }> {
  try {
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )
    
    // Read file
    const fileStream = createReadStream(zipPath)
    const chunks: Buffer[] = []
    
    for await (const chunk of fileStream) {
      chunks.push(chunk as Buffer)
    }
    
    const fileBuffer = Buffer.concat(chunks)
    
    // Upload to Supabase Storage
    const fileName = `${projectId}.zip`
    const filePath = `projects/${userId}/${fileName}`
    
    const { data, error } = await supabase.storage
      .from('projects')
      .upload(filePath, fileBuffer, {
        contentType: 'application/zip',
        upsert: true
      })
    
    if (error) {
      return {
        success: false,
        error: error.message
      }
    }
    
    // Get public URL
    const { data: urlData } = supabase.storage
      .from('projects')
      .getPublicUrl(filePath)
    
    return {
      success: true,
      url: urlData.publicUrl
    }
    
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error)
    }
  }
}

/**
 * Get project size (in bytes)
 */
export async function getProjectSize(projectPath: string): Promise<number> {
  let totalSize = 0
  
  async function calculateSize(dirPath: string) {
    const entries = await readdir(dirPath, { withFileTypes: true })
    
    for (const entry of entries) {
      const fullPath = join(dirPath, entry.name)
      
      // Skip common excludes
      if (shouldExclude(entry.name, ['node_modules', '.next', '.git'])) {
        continue
      }
      
      if (entry.isDirectory()) {
        await calculateSize(fullPath)
      } else if (entry.isFile()) {
        const stats = await stat(fullPath)
        totalSize += stats.size
      }
    }
  }
  
  await calculateSize(projectPath)
  return totalSize
}

/**
 * Format file size
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i]
}
